import cv2 as cv
from skimage import measure
from skimage.measure import regionprops
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import pytesseract


#resizing the image so the o/p can fit on the screen
def resize(img, scaleInPercent):
    width = int(img.shape[1] * scaleInPercent / 100)
    height = int(img.shape[0] * scaleInPercent / 100)
    dim = (width, height)
    imgResized = cv.resize(img, dim, interpolation=cv.INTER_AREA)
    return imgResized

def preProcessingImg(imgPath):
    imgGray = cv.imread(imgPath, cv.IMREAD_GRAYSCALE)
    #Apply adaptive threshold to the grayscale image 11->BlockSize, 2->Coffset
    imgAdaptiveThresh = cv.adaptiveThreshold(imgGray, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2)
    #Apply Canny edge detection, 100->minVal(this is the 1st threshold for the hysterisis procedure)
    #edges higher than this threshold are considered edges
    #200->maxVal(this is the 2nd threshold for the hysterisis procedure)
    #edges lower than this are discarded unless they are connected to edges with higher gradient
    #edges b/w minVal and maxVal are kept if they are connected
    edges = cv.Canny(imgAdaptiveThresh, 100, 200)
    return imgGray, imgAdaptiveThresh, edges

def isPossibleLicensePlate(region, img):
    minRow, minCol, maxRow, maxCol = region.bbox
    #region Height and region Width are the dimension of our bounding box
    regionHeight = maxRow - minRow
    regionWidth = maxCol - minCol
    #When the aspect Ratio is more than 1 then it means the detected object has more width than height
    aspectRatio = float(regionWidth) / regionHeight
    #slicing the tuple coz we need to extract 1st two elements i.e height and width , we dont need clour channel
    #so we are ignoring it 
    imgHeight, imgWidth = img.shape[:2]
    #proportionWidth & proportionHeight are the ratio of height and width to the total img height & width
    proportionWidth = float(regionWidth) / imgWidth
    proportionHeight = float(regionHeight) / imgHeight
    area = region.area
    #the range of proportion width and height is b/w (.15 and .4) and (.08 and 0.2)
    #to ensure that the region is not too wide and too tall
    return (aspectRatio > 1 and aspectRatio < 6 and 0.15 <= proportionWidth <= 0.40 and 0.08 <= proportionHeight <= 0.20 and area > 500)

def verifyPlate(img, bbox):
    minRow, minCol, maxRow, maxCol = bbox
    plateImg = img[minRow:maxRow, minCol:maxCol]
    plateText = pytesseract.image_to_string(plateImg, config='--psm 8')
    return any(char.isalnum() for char in plateText)

def haarCascadeDetect(imgGray):
    #Here we will load a pre trained  Haar Cascade Classifier for license plate
    plateCascade = cv.CascadeClassifier(cv.data.haarcascades + 'haarcascade_russian_plate_number.xml')
    plates = plateCascade.detectMultiScale(imgGray, scaleFactor=1.05, minNeighbors=3, minSize=(30, 30))
    return plates

def regionPropsDetect(edges, img):
    #label all connected components(group  of connected pixels)in the binary img
    labelImage = measure.label(edges)
    #Creating a list to store the detected regions that are possible license plates
    detectedRegions = []
    for region in regionprops(labelImage):
        #skip the region if the area is less than 50 pixels
        if region.area < 50:
            continue

        #checking the properties of the img again by calling the function
        #if the region is a possible license plate then append it to the detectedRegions list
        if isPossibleLicensePlate(region, img):
          #after confirming that the region is a possible license plate a bounding box is drawn around it  
            detectedRegions.append(region.bbox)
            #returnign the list of the bounding box of the detected regions
    return detectedRegions

def plateLocalization(imgPath):
    img = cv.imread(imgPath)
    grayScaleImg, imgAdaptiveThresh, edges = preProcessingImg(imgPath)
    detected_plates = []

    # Conditional method selection
    if grayScaleImg.mean() < 100:
        #apply haar cascade to detect the plates
        plates = haarCascadeDetect(grayScaleImg)
        #this loop will draw a rectangle around the detected plates
        for (x, y, w, h) in plates:
            if verifyPlate(grayScaleImg, (y, x, y+h, x+w)):
                #here detected_plates is a list that holds the coordinates of the detected plates
                #append is used to add the coordinates of the detected plates
                detected_plates.append((x, y, w, h))
                cv.rectangle(img, (x, y), (x+w, y+h), (255, 0, 0), 2)
    else:
        regions = regionPropsDetect(edges, img)
        fig, ax = plt.subplots(1)
        ax.imshow(cv.cvtColor(img, cv.COLOR_BGR2RGB))
        for bbox in regions:
            if verifyPlate(grayScaleImg, bbox):
                minRow, minCol, maxRow, maxCol = bbox
                rectBorder = patches.Rectangle((minCol, minRow), maxCol-minCol, maxRow-minRow, edgecolor="red", linewidth=2, fill=False)
                ax.add_patch(rectBorder)
                cv.rectangle(img, (minCol, minRow), (maxCol, maxRow), (255, 0, 0), 2)
        plt.show()

    ResizedImg = resize(img, 60)
    cv.imshow('Plate Localization', ResizedImg)
    cv.waitKey(0)
    cv.destroyAllWindows()

#imgPath=r"D:\sample img for Lpr\CarPlate.jpg"
#imgPath=r"D:\sample img for Lpr\CarPlate1.jpg"
#imgPath = r"D:\sample img for Lpr\CarPlate2(JPG).jpg"
#imgPath=r"D:\sample img for Lpr\CarPlate3.jpg"
imgPath = r"D:\sample img for Lpr\CarPlate4.jpg"
plateLocalization(imgPath)

